{"name":"JPropel-light","body":"# Hi there!\r\n\r\njpropel-light is a Java library which can seriously hinder your salary if you are paid by the number of lines of code you create!\r\n\r\n    // create alphabet char[]\r\n    char[] alphabet = new Character('A').to(new Character('Z')).unbox();\r\n \r\n    // join two arrays and put in list \r\n    List<Character> allowed = alphabet.join(numbers).toList(); \r\n\r\n    // select names starting with j, using LINQ-style statements\r\n    new String[] { \"james\", \"john\", \"john\", \"eddie\" }.where(startsWith(\"j\")).distinct().all(println());\r\n    \r\n\r\nIt is a free and open-source Java library aiming to cut down code bloat, boilerplate and generally the number of lines of code Java developers have to write in order to complete a task.\r\n\r\nIt comes with full LINQ support, reified generic collections and concise one-liners for performing common tasks such as reading an entire text file into memory, array manipulations, XML processing/querying, etc. \r\nLet's examine some of them.\r\n\r\n\r\n\r\n## LINQ\r\n\r\nA very popular language feature of C#, Language INtegrated Query adds native data querying capabilities. These can, for example, be used to project and filter data in arrays and enumerable classes (source: [LINQ](http://en.wikipedia.org/wiki/LINQ))\r\n\r\n    var results = someCollection.where(c => c.SomeProperty < someValue * 2);\r\n\r\nHere is an equivalent Java snippet:\r\n\r\n    List<SomeElement> results = new ArrayList<SomeElement>();\r\n    for(SomeElement c : SomeCollection)\r\n      if(c.SomeProperty < someValue * 2)\r\n        results.add(c);\r\n\r\nThis is a trivial example, but it becomes obvious that for more complex queries, such as group by, select many, etc. the code becomes much more verbose. Even the low level of verbosity shown above hides the real purpose of the snippet, so one has to read it multiple lines of code in their entirety to understand it. This gets in the way of the developer and is not good for productivity. \r\n\r\nSo is the following *valid* Java code perhaps better?\r\n\r\n    List results = someCollection.where(propertyLessThan(someValue*2));\r\n\r\nHow is this possible? Well, firstly we have to import the right class, which would be the Linq class of the framework. It has implementations for all methods found in the .NET implementation such as: [all, any, select, where, distinct, first, last, zip, etc.](https://github.com/nicholas22/jpropel-light/blob/master/src/propel/core/utils/Linq.java)\r\n\r\nThe second step is to annotate the class that contains your code with the @ExtensionMethod annotation, imported from a library called [lombok-pg](https://github.com/peichhorn/lombok-pg). This library makes a lot of the shown syntactic sugar possible by instructing your compiler to pre-process the class code before compiling. This is done transparently to the developer. As far as bytecode is concerned, the code is converted to standard Java calls. So for the snippet above, the code effectively becomes:\r\n\r\n    List results = Linq.where(someCollection, propertyLessThan(someValue*2));\r\n\r\nThis you will recognise is standard Java static method call. This is how [extension methods](http://en.wikipedia.org/wiki/Extension_method) work under-the-hood in other languages too. \r\nBut crucially, you as a developer *do not* have to work as such and can be much more expressive, using a fluent API: \r\n\r\n    new String[] {\"james\",\"john\",\"john\",\"eddie\"}.where(startsWith(\"j\").select(toUppercase()).distinct().toList();\r\n\r\nIsn't that nice? :)\r\n\r\nThe above statement returns [\"JAMES\", \"JOHN\"] and is more readable and concise than the following equivalent (but horrible) statement:\r\n\r\n    Linq.toList(Linq.distinct(Linq.select(Linq.where(new String[] { \"james\",\"john\",\"john\",\"eddie\"}, startsWith(\"j\")), toUppercase())));\r\n\r\nIt's verbose and bug prone because it's hard to understand. Let's get back on the prettier version:\r\n\r\n    new String[] {\"james\",\"john\",\"john\",\"eddie\"}.where(startsWith(\"j\").select(toUppercase()).distinct().toList();\r\n\r\n\r\nThe other interesting with the above statement is how can we seemingly pass functions as arguments (e.g. see startsWith, toUppercase). Everyone knows that Java does not have first class functions, in other words, cannot pass methods/functions around as objects. This is another area where lombok-pg helps us, allowing for the annotation of methods/functions with @Function, enabling easier functional programming in Java. \r\n\r\n    @Function \r\n    private static String toUppercase(String element) { \r\n       return element.toUpperCase(); \r\n    }\r\n\r\nThe above annotation will pre-process the code by wrapping the annotated function in an anonymous class, allowing us to pass it around as an object. This is what the resulting code would look like if you decompiled the class:\r\n\r\n    private static Function1<String, String> toUppercase(String element) {\r\n      return new Function1<String, String>() {\r\n        public String apply(String arg) { \r\n          return element.toUpperCase(); \r\n        } \r\n      } \r\n    }\r\n\r\nThis is very similar to how Scala functions are implemented. You can then pass these 'functions' (which are really just Java objects / anonymous classes) around, just like you would pass objects around in other languages. And these are the types of objects that the Linq class accepts as selectors, predicates, filters, etc. Here is for example the source code of the select() method:\r\n\r\n    public static TResult[] select(final TSource[] values, final Function1<TSource, TResult> selector) \r\n    { \r\n      List result = new ArrayList(values.length); \r\n    \r\n      for(TSource item : values) \r\n        result.add(selector.apply(item)); \r\n    \r\n      return toArray(result, selector.getReturnType()); \r\n    }\r\n\r\nAs you can see, all the above method does is call the apply() method of the function to extract the required data, oblivious to the actual implementation of your selector. The JPropel library comes with a number of predicates and projections built-in, such as the ones shown above e.g. startsWith, endsWith, contains, equal, etc. The Linq class static methods accept these as well as custom (written by you!) functions to perform select, where and other such operations, in a way that is suitable to your program.\r\n\r\nThe JVM deals with anonymous classes very frequently when you code against it using languages such as Scala. A benchmark between [C++, Go, Java and Scala](http://www.readwriteweb.com/hack/2011/06/cpp-go-java-scala-performance-benchmark.php) which made the news recently, showed that Scala's performance is very much on par with Java's. So clearly the JVM can cope with wrapping methods into anonymous classes pretty well. Therefore there is a minimal performance consideration when using such code, but you can also cache such 'functions' around when you know you will use them very frequently.\r\n\r\nMost Linq methods come in two flavors. One accepts generic arrays and one accepts generic Iterables. There are two reasons for this. Firstly, arrays and Iterables do not share a common super class which would allow for traversal of items. Secondly, arrays and Iterables are handled completely differently from the JPropel library perspective. \r\n\r\nSo when you pass an array to be processed, the resulting array is allocated and all results are inserted before it is returned. This is not the case with iterables. Iterables are created using a block iterator, similarly to how yielding works in C# and is down to lombok's [yield construct](http://peichhorn.github.com/lombok-pg/Yield.html). This means that if you do not iterate over the entire collection, then only some of the elements are processed, which is more efficient, because it allows you, for instance, to break the iteration process without consuming as much memory and processing resources as the array would.\r\n\r\n\r\n\r\n## Reified generic collections\r\n\r\nGenerics in Java are implemented using [type erasure](http://en.wikipedia.org/wiki/Type_erasure). This means that generic type information is removed at run-time. A list of integers and a list of strings have the same class type in Java, which creates an interesting set of problems in areas such as overloading, instantiation and introspection. Type erasure is considered by many an inferior way of implementing generics. The subject of [erasure vs reification](http://beust.com/weblog/2011/07/29/erasure-vs-reification/) has been covered neatly already so let's focus on what's important here. Since the JVM erases the run-time type of generics, we have to live with this. Or do we?\r\n\r\nNeil Gafter came up with a workaround to this problem, called [super-type token](http://gafter.blogspot.com/2006/11/reified-generics-for-java.html). The whole idea is based on the fact that the JVM does not erase type information of anonymous classes. Therefore if you instantiate a class using anonymous class semantics, you can query its run-time type parameter(s): \r\n\r\n    List<String> list = new ArrayList<String>() {}; // note: braces after parentheses\r\n\r\nThe JPropel library embraces this pattern and provides a wide array of collections that follow it, such as Lists, Maps, Hashtables and others.  This allows you to do common sense things such as:\r\n\r\n    LinkedList<String> list = new LinkedList<String>(){};\r\n    String[] items = list.toArray();\r\n\r\nWith type-erased collections you would have to do nonsensical things such as: \r\n\r\n    Object[] items = list.toArray();\r\n\r\nor\r\n\r\n    String[] items = list.toArray(new String[list.size()]);\r\n\r\nBeing able to query the run-time type parameter can bring several benefits, especially if you are creating a generic container, e.g. your own collection classes. But in such scenarios, if you have multiple layers of generic containers, you may not be able to reliably obtain the run-time type information. One example:\r\n\r\n    public class MyClass<T> {\r\n      public MyClass() {\r\n        List<T> list = new ReifiedArrayList<T>() {}; // no can do\r\n      }\r\n    }\r\n\r\nThe reason this is not possible, is because the type T of MyClass is not known. In such scenarios you have to pass the type explicitly, as such:\r\n\r\n    public class MyClass<T> {\r\n      public MyClass() {\r\n        Class<?> clazz = SuperTypeToken.getClazz(this);\r\n        List<T> list = new ReifiedArrayList<T>(clazz) {}; // OK\r\n      }\r\n    }\r\n\r\nYou then go ahead and instantiate MyClass using anonymous class semantics, as shown above (or pass the type explicitly if you wish). Although this is not ideal, at least it is possible to accommodate for multi-level generic containers.\r\n\r\nFinally, it is also possible to instantiate collections with multiple type parameters:\r\n\r\n    AvlHashtable<UUID, String> lookup = AvlHashtable<UUID, String>() {};\r\n    Iterable<UUID> keys = lookup.getKeys();\r\n    Iterable<String> values = lookup.getValues();\r\n\r\nThis is possible because the SuperTypeToken class has an overloaded method that allows you to obtain the generic run-time parameter type based on its zero-based index.\r\n\r\n\r\n\r\n## Fun with utilities\r\n\r\nThere are a lot of very concise one-liners supported by the library which allow you to focus on the task at hand instead of writing boilerplate. Here are some examples:\r\n\r\n    // create alphabet\r\n    char[] alphabet = new Character('A').to(new Character('Z'));\r\n    char[] numbers = new Charracter('1').to(new Character('9'));\r\n    \r\n    // join two arrays and put in a list\r\n    List<Character> allowed = alphabet.join(numbers).toList();\r\n    \r\n    // load entire text file in memory\r\n    String data = file.readFileToEnd();\r\n    \r\n    // append to file\r\n    file.appendText(\"Some more text\");\r\n    \r\n    // XML compacting\r\n    String compacted = someXml.compact();\r\n    \r\n    // copy stream over\r\n    inputStream.copy(outputStream);\r\n    \r\n    // Culture-aware case-insensitive string comparison\r\n    boolean trueInGermany = StringUtils.equal(\"straße\", \"STRASSE\", StringComparison.CurrentCultureIgnoreCase);\r\n    \r\n    // check if all elements are present\r\n    boolean itsTrue = \"abcdef\".containsAll(new String[] {\"bc\", \"cd\"}, StringComparison.Ordinal);`\r\n\r\n    // benchmark\r\n    Stopwatch sw = Stopwatch.startNew();\r\n    long ns = sw.getElapsedNanos();\r\n\r\nThere are too many utilities to cover here, around the areas of reflection, XML, conversions (e.g. binary, octal, hex, decimal, base64, etc.), character escaping, hashing, strings, etc. Have a look at the [propel.core.utils.*](https://github.com/nicholas22/jpropel-light/tree/master/src/propel/core/utils) package for more. For more examples also see [the JPropel changelog] (https://github.com/nicholas22/jpropel) \r\n\r\n\r\n## JPropel\r\n\r\nJPropel-light (this project!) is a lightweight version of the [JPropel](https://github.com/nicholas22/jpropel) library. If you do not mind an extra dependency (SLF4j), have a look as it contains some extra utility functionality.\r\n\r\nFor instance, the CryptographicString class allows you to store a secret in memory in encrypted form:\r\n\r\n    CryptographicString cs = new CryptographicString(\"super secret\"); \r\n    char[] unencrypted1 = cs.asCharArray();\r\n    byte[] unencrypted2 = cs.asByteArray();\r\n    String unencrypted3 = cs.asString(); // beware of String interning\r\n\r\nAnother construct you may find interesting is the ability to trace method calls, logging all input and output data (or exceptions thrown) in a highly configurable way. This is done without any AOP library dependencies or custom AOP language.\r\n\r\n    @Trace(level=LogLevel.INFO)\r\n    public int add(int a, int b) { \r\n       return a+b;\r\n    }\r\n\r\nThis allows you to focus on the task at hand without worrying if you have enough logging within a method. To enable the tracing you have to instantiate your class (perhaps via a factory newInstance() method) in a way that allows the tracing to take place:\r\n\r\n    MyInterface myClass = new Tracer<MyInterface>(new MyClass());\r\n\r\nAll calls to methods of the myClass instance that have been annotated with @Trace will emit logging statements of all method arguments, results (if not void) and exceptions (if thrown). The logger uses  SLF4j so will plug into any popular logging library you are using. The format of messages is highly configurable as well.\r\n\r\nFinally, another nice feature is a validation framework, where you define your POJOs' metadata and can validate in a single line of code, removing the need for convoluted if-then-else statements sprinkled around many places in your code:\r\n\r\n    boolean notNull = true;\r\n    boolean notEmpty = true;\r\n    boolean notNullChars = true;\r\n    StringPropertyMetadata name = new StringPropertyMetadata(\"Name\", 3, 20, notNull, notEmpty, notNullChars);\r\n\r\n    // perform validation\r\n    name.validate(null); // \"Name cannot be null\"\r\n    name.validate(\"\"); // \"Name cannot be empty\"\r\n    name.validate(\"John\"); // OK\r\n    name.validate(\"Jo\"); // \"Name cannot be 2 or fewer characters in length\"\r\n    name.validate(\"123456789012345678901\"); // \"Name cannot be 21 or more characters in length\"\r\n\r\n\r\n\r\n## PropelS\r\n\r\nA [Scala port of JPropel](https://github.com/nicholas22/propels) has been started!\r\n\r\n\r\n\r\n##Lombok-pg\r\n\r\nJPropel and JPropel-light depend on the [lombok-pg](https://github.com/peichhorn/lombok-pg) library. \r\n\r\nIf you are using an IDE such as Eclipse, Netbeans or IntelliJ, you should patch it so that it uses lombok as \r\na Java agent. The process is very simple: just double-click on the lombok.jar found in the \"lib\" folder. This will enable much of the syntactic sugar shown above.\r\n\r\nJavac and Ant do not require any patching as such.\r\n\r\nYou may visit the [lombok](http://projectlombok.org/slideshow.html) project website for more info, or ask [Philipp](https://github.com/peichhorn) more about it.\r\n\r\n\r\n##Changelog\r\n\r\n####1.1.3: Minor improvements\r\nIncluded Eclipse project in sources JAR.  \r\nAdded EnvironmentUtils utility class, allows for altering JVM env. vars at run-time.  \r\nAdded Stopwatch.restart() convenience method.  \r\nAdded Iterable validator (IterablePropertyMetadata)  \r\nAdded URL validator (URLPropertyMetadata)  \r\nAdded a few commonly used predicates (propel.core.functional.predicates.*)\r\nStackTraceLogger now has configurable level, showing minimal, abbreviated or full trace.  \r\nFixed inaccurate comments in NumericUtils, StringUtils, Linq, etc.  \r\nLinq unzip() and partition() methods added. Bug-fixing (ofType, orderByThenBy, skip)  \r\nUsing lombok-pg 0.10.8-SNAPSHOT dependency.  \r\n\r\n\r\n\r\n####1.1.2: Performance improvements\r\nLongHashMap now has very fast lookup performance and smaller memory footprint.  \r\nA way to \"seal\" classes and make them immutable has been added via ReflectionUtils.proxy().  \r\nIt works by preventing certain methods to be called and as such guaranteeing immutability for things like collections.  \r\nUsing a long->T LongHashMap and this feature, you can create a hash map that is x5 faster than ConcurrentHashMap in lookups, due to absence of locking.  \r\nSee ImmutableUtils.toReadOnly() for an implementatiof of this.  \r\nAlso, removed SharedLongHashMap implementation for now.  \r\n\r\n\r\n\r\n####1.1.1: Primitive collections and counters\r\nAdded primitive collections: FixedSizeLongBuffer, SharedFixedSizeLongBuffer, LongHashMap, SharedLongHashMap.  \r\nAdded more counters: SharedModuloIndexer, SharedModuloIndexerLight (specialised, for traversing buffers/arrays).  \r\n\r\n\r\n\r\n####1.1.0: bugfix & clean-up\r\nRemoved old v1.0.8 and v1.0.9 JARs.  \r\nBugfix for StringUtils.replace()  \r\n\r\n\r\n\r\n####1.0.9: incremental update\r\nReplaces usages with StringBuilder instead of StringBuffer.  \r\nFixed StringUtils padLeft/padRight comments.  \r\nAdded projections: getClassType(), getClassName(), getClassNameSimple().  \r\nUpdated Objects.* predicates to use Object instead of T where a type is not needed  \r\n(this is to alleviate some type inferencing woes with javac/ecj)  \r\nAdded print() predicate to Objects and Strings classes.  \r\nAdded min() and max() to Linq.  \r\nAdded minOccurring() and maxOccurring() to Linq.  \r\n(using non-parallel map/reduce which could be optimised in a next version)  \r\nUpgraded to lombok-pg-0.10.4  \r\n\r\n\r\n\r\n####1.0.8: upgrade lib\r\nUpgraded to lombok-pg-0.10.2 and deployed second jar, which includes sources.  \r\n\r\n\r\n\r\n####1.0.7: InvokeOneArg, InvokeNoArg\r\nFunctional invocation is now cleaner, by using static imports on methods of these two classes.  \r\n\r\n\r\n\r\n####1.0.6: SharedMapMultimap \r\nThread-safe version of MapMultimap (SharedMapMultimap)  \r\nLinq.single() ensuring a single element exist in an iterable/array.  \r\nStringUtils.crop() is a trim-like function where you specify which characters to leave in, rather than trim.  \r\n\r\n\r\n\r\n####1.0.5: Predicates split up Objects, Strings, Arrays and Iterables classes\r\nA breaking change for the modularization of predicates\r\n\r\n\r\n\r\n####1.0.4: Function1<?, Boolean> became Predicate1<?>\r\nA breaking change that uses the @Predicate annotation instead of @Function. Annotated methods return Predicate1<?> instead of Function1<?, Boolean>\r\n\r\n\r\n\r\n####1.0.3: Minor improvements\r\n\r\n####MapMultimap data structure\r\nAnother type-aware collection, a \"map of maps\".\r\n\r\n     val map = new MapMultimap<String, String, Integer>() {};\r\n     map.put(\"Male\", \"Nick\", 18);\r\n     map.put(\"Male\", \"John\", 25);\r\n     map.put(\"Female\", \"Jo\", 20);\r\n\r\n     // get map of all males\r\n     Map<String, Integer> males = map.get(\"Male\");\r\n\r\n     // check if anyone is 23 years old\r\n     boolean notTrue = map.getValue(23);\r\n\r\n####Improved extension method support for java.io.File\r\nMost methods in FileUtils will now accept a File object as first argument, facilitating extension method use:\r\n\r\n     // line-oriented file input\r\n     String[] lines = new File(\"myFile.txt\").readFileToEnd().split(\"\\r\\n\");\r\n\r\n\r\n\r\n####1.0.2: New features, upgrades, etc.\r\nLots of new statically importable predicates and projections:\r\n\r\n    import static propel.core.functional.predicates.Predicates.*;\r\n    import static propel.core.functional.projections.Projections.*;\r\n\r\nexamples: instanceOf(), appendToFile(), copyFile, moveFile(), etc.\r\n\r\n####Matcher allowing for fewer if-then-else statements (beta!)\r\n\r\n    val matcher = new Matcher<Object, Person>();\r\n\r\n    // wire-up appropriate matching conditions to handlers\r\n    matcher.addAction(instanceOf(SalesPerson.class), salesHandler);\r\n    matcher.addAction(instanceOf(MarketingPerson.class), marketingHandler);\r\n    matcher.addAction(instanceOf(AdminPerson.class), adminHandler);\r\n\r\n    // this is the default action, will match if nothing else matches\r\n    matcher.setDefaultAction(throwDetailed(new Exception(\"An unrecognised person type was given: \")));\r\n\r\n####Functional transaction manager\r\nA transaction manager which accepts functions as actions and rollback actions.\r\n\r\n    // we will transactionally replace a file, i.e. revert changes if something fails\r\n    ITransactionManager tm = new TransactionManager();\r\n\r\n    String originalPath = \"/source/file\"\r\n    String destinationPath = \"/destination/file\";\r\n    String tempPath = destinationPath + CONSTANT.DOT + RandomUtils.getPseudoAlphanumericText(16);\r\n\r\n    // action is to move the file to a temporary location, upon failure move it back\r\n    if (new File(originalPath).exists())\r\n      tm.add(moveFile(originalPath, tempPath), moveFile(tempPath, originalPath));\r\n\r\n    // action is to append file contents, upon failure delete this new file\r\n    tm.add(appendToFile(originalPath, xmlData), deleteFile(originalPath));\r\n\r\n    // action is to delete temporary file, this is last action hence no need for recovery counter-action\r\n    tm.add(deleteFile(tempPath));\r\n\r\n    // perform operations, upon failure this will execute all rollback actions, before re-throwing\r\n    tm.commitWithRollback();\r\n\r\n\r\n\r\n####1.0.1: Added println() predicate\r\n\r\n    new String[] { \"hello\", \"world\" }.all(println());\r\n\r\n\r\n\r\n####1.0.0: Creation\r\nLightweight version forked from [JPropel](https://github.com/nicholas22/jpropel)","tagline":"Leaner version of jpropel, containing only LINQ, reified collections and utilities for arrays/strings/numerics/files/xml etc.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}